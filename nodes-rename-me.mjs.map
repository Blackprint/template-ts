/* Your Nodes 
 MIT Licensed */
{
  "version": 3,
  "sources": ["bp-plugins:@_bp_internal", "bp-plugins:@blackprint/engine", "src/_context.ts", "src/FeatureName/Template.ts"],
  "sourcesContent": ["\n\t\t\t\t\t\t\t\texport let Blackprint = globalThis.Blackprint.loadScope({\n\t\t\t\t\t\t\t\t\turl: import.meta.url,\n\t\t\t\t\t\t\t\t\thasInterface: true,\n\t\t\t\t\t\t\t\t\thasDocs: true,\n\t\t\t\t\t\t\t\t}) as typeof import(\"@blackprint/engine\");\n\n\t\t\t\t\t\t\t\tlet sf = globalThis.sf;\n\t\t\t\t\t\t\t\texport async function _imports_(moduleName: string, url: string){\n\t\t\t\t\t\t\t\t\tlet loadFromURL = globalThis.Blackprint.Environment.loadFromURL;\n\t\t\t\t\t\t\t\t\tif(loadFromURL && sf?.loader != null){\n\t\t\t\t\t\t\t\t\t\treturn (await sf.loader.mjs([url]))[0];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn await import(loadFromURL ? url : moduleName);\n\t\t\t\t\t\t\t\t};", "\n\t\t\t\t\t\t\timport { Blackprint } from \"@_bp_internal\";\n\t\t\t\t\t\t\texport default Blackprint;", "import Blackprint from \"@blackprint/engine\";\n\n// This is required for accessing data between .ts and .sf module\nexport let Context = Blackprint.createContext(\"LibraryName\");\n\n// This is needed to avoid duplicated event listener when using hot reload\n// Event listener that registered with same slot will be replaced\nContext.EventSlot = {slot: 'my-private-event-slot'};", "import Blackprint from \"@blackprint/engine\";\nimport { Context } from \"_context\";\n\n// BPIC/LibraryName is prefix from blackprint.config.js\n// This file is just reference, you can remove unnecessary property/function\n\n// Node will be initialized first by Blackprint Engine\n// This should be used for initialize port structure and set the target interface\n@Blackprint.registerNode('LibraryName/FeatureName/Template')\nexport class Node extends Blackprint.Node<typeof Node> {\n\t// this == node\n\n\t// You can use type data like Number/String or \"Blackprint.Port\"\n\t// use \"Blackprint.Port.Trigger\" if it's callable port\n\tstatic input = {\n\t\tPortName1: Blackprint.Port.Default(Number, 123)\n\t};\n\n\t// Output only accept 1 type data\n\t// use \"Function\" if it's callable port\n\tstatic output = {\n\t\tPortName2: Number\n\t};\n\n\tconstructor(instance: Blackprint.Engine){\n\t\tsuper(instance);\n\n\t\t// Interface path\n\t\t// Let it empty if you want to use default built-in interface\n\t\t// You don't need to '.registerInterface()' if using default interface\n\t\tlet iface = this.setInterface('BPIC/LibraryName/FeatureName/Template');\n\t\tiface.title = 'My Title';\n\t\tiface.description = 'My Description';\n\t}\n\n\t// Put logic as minimum as you can in .registerNode\n\t// You can also put these function on .registerInterface instead\n\tinit(){\n\t\t// Called before iface.init()\n\t}\n\n\t// This is more recomended than using event listener \"port.value\" or \"value\"\n\t// If you want to trigger this manually, you may also need to trigger route out `this.routes.routeOut();`\n\tupdate(cable: Blackprint.Cable){\n\t\t// Triggered when any output value from other node are updated\n\t\t// And this node's input connected to that output\n\t}\n\n\timported(data: Object){\n\t\t// When this node was successfully imported\n\t\t// iface can also has this function feature, please use one only\n\t}\n\n\trequest(cable: Blackprint.Cable){\n\t\t// Triggered when other connected node is requesting\n\t\t// output from this node that have empty output\n\t}\n\n\t// Add support for remote sync (this will receive data from .syncOut)\n\tsyncIn(eventName: string, value: any){\n\t\tif(eventName === 'data.value')\n\t\t\tthis.iface.data.value = value;\n\t}\n}\n\n// For Non-sketch interface\n// - first parameter is named path must use BPIC prefix\n// - second parameter is interface class, should be saved to Context.IFace if you want to access it on '.sf' files, because '.sf' is executed on different context\n@Blackprint.registerInterface('BPIC/LibraryName/FeatureName/Template')\nexport class Interface extends Blackprint.Interface<Node> {\n\t// this == iface\n\n\tconstructor(node: Node){\n\t\tsuper(node); // 'node' object from .registerNode\n\n\t\tthis.myData = 123;\n\t\tthis._log = '...';\n\n\t\t// If the data was stored on this, they will be exported as JSON\n\t\t// (Property name with _ or $ will be ignored)\n\t\tthis.data = {\n\t\t\t_iface: this,\n\t\t\tget value(){ return this._value },\n\t\t\tset value(val){\n\t\t\t\tthis._value = val;\n\n\t\t\t\t// Add support for remote sync: .syncOut(eventName, value);\n\t\t\t\t// The data will be received in: syncIn(event, value);\n\t\t\t\tthis._iface.node.syncOut('data.value', val);\n\t\t\t},\n\t\t};\n\n\t\t// Creating object data with class is more recommended\n\t\t// this.data = new MyDataStructure(this);\n\t}\n\n\t// When importing nodes from JSON, this function will be called\n\timported(data: Object){\n\t\t// Use object assign to avoid replacing the object reference (that makes our getter/setter gone)\n\t\tObject.assign(this.data, data);\n\t}\n\n\tinit(){\n\t\t// When Engine initializing this scope\n\n\t\t// ====== Port Shortcut ======\n\t\tconst {\n\t\t\tIInput, IOutput, // Port interface\n\t\t\tInput, Output, // Port value\n\t\t} = this.ref;\n\n\t\t// Port interface can be used for registering event listener\n\t\t// Port value can be used for get/set the port value\n\n\t\t// this.output === IOutput\n\t\t// this.input === IInput\n\t\t// this.node.output === Output\n\t\t// this.node.input === Input\n\n\t\t// this.output.Test => Port Interface\n\t\t// this.node.output.Test => Number value\n\n\t\t// For some event listener please see on ./Template.sf\n\t}\n\n\t// Create custom getter and setter\n\tget log(){ return this._log }\n\tset log(val){\n\t\tthis._log = val\n\t}\n}\n\nContext.IFace['FeatureName/Template'] = Interface;"],
  "mappings": "oVACe,IAAIA,EAAa,WAAW,WAAW,UAAU,CACvD,IAAK,YAAY,IACjB,aAAc,GACd,QAAS,EACV,CAAC,EAEGC,EAAK,WAAW,GCLrB,IAAOC,EAAQC,ECCf,IAAIC,EAAUC,EAAW,cAAc,aAAa,EAI3DD,EAAQ,UAAY,CAAC,KAAM,uBAAuB,ECE3C,IAAME,EAAN,cAAmBC,EAAW,IAAkB,CAetD,YAAYC,EAA4B,CACvC,MAAMA,CAAQ,EAKd,IAAIC,EAAQ,KAAK,aAAa,uCAAuC,EACrEA,EAAM,MAAQ,WACdA,EAAM,YAAc,gBACrB,CAIA,MAAM,CAEN,CAIA,OAAOC,EAAwB,CAG/B,CAEA,SAASC,EAAa,CAGtB,CAEA,QAAQD,EAAwB,CAGhC,CAGA,OAAOE,EAAmBC,EAAW,CACjCD,IAAc,eAChB,KAAK,MAAM,KAAK,MAAQC,EAC1B,CACD,EAjDCC,EALYR,EAKL,QAAQ,CACd,UAAWC,EAAW,KAAK,QAAQ,OAAQ,GAAG,CAC/C,GAIAO,EAXYR,EAWL,SAAS,CACf,UAAW,MACZ,GAbYA,EAANS,EAAA,CADNR,EAAW,aAAa,kCAAkC,GAC9CD,GA4DN,IAAMU,EAAN,cAAwBT,EAAW,SAAgB,CAGzD,YAAYU,EAAW,CACtB,MAAMA,CAAI,EAEV,KAAK,OAAS,IACd,KAAK,KAAO,MAIZ,KAAK,KAAO,CACX,OAAQ,KACR,IAAI,OAAO,CAAE,OAAO,KAAK,MAAO,EAChC,IAAI,MAAMC,EAAI,CACb,KAAK,OAASA,EAId,KAAK,OAAO,KAAK,QAAQ,aAAcA,CAAG,CAC3C,CACD,CAID,CAGA,SAASP,EAAa,CAErB,OAAO,OAAO,KAAK,KAAMA,CAAI,CAC9B,CAEA,MAAM,CAIL,GAAM,CACL,OAAAQ,EAAQ,QAAAC,EACR,MAAAC,EAAO,OAAAC,CACR,EAAI,KAAK,GAcV,CAGA,IAAI,KAAK,CAAE,OAAO,KAAK,IAAK,CAC5B,IAAI,IAAIJ,EAAI,CACX,KAAK,KAAOA,CACb,CACD,EA7DaF,EAAND,EAAA,CADNR,EAAW,kBAAkB,uCAAuC,GACxDS,GA+DbO,EAAQ,MAAM,sBAAsB,EAAIP",
  "names": ["Blackprint", "sf", "engine_default", "Blackprint", "Context", "engine_default", "Node", "engine_default", "instance", "iface", "cable", "data", "eventName", "value", "__publicField", "__decorateClass", "Interface", "node", "val", "IInput", "IOutput", "Input", "Output", "Context"]
}
